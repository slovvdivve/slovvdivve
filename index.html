<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Hook Arena — GH Pages Multiplayer (r8)</title>
  <style>
    html, body { height: 100%; margin: 0; background:#0b0f17; }
    #root { height: 100%; display:grid; place-items:center; }
    canvas { image-rendering: pixelated; background:#0b0f17; outline:none; }
    .hint{position:fixed;left:50%;transform:translateX(-50%);top:10px;color:#e2e8f0;font:14px/1.4 system-ui,sans-serif;background:#0f172a;border:1px solid #334155;border-radius:10px;padding:8px 12px}
    .hud{position:fixed;left:10px;top:10px;color:#e5e7eb;font:14px/1.3 system-ui,sans-serif;opacity:.9}
    .menuBtn{position:fixed;right:12px;top:12px;background:#1f2937;border:1px solid #334155;color:#e5e7eb;border-radius:8px;padding:8px 12px;cursor:pointer}
    .menuPanel{position:fixed;right:12px;top:56px;background:#0b1220;border:1px solid #334155;color:#e5e7eb;border-radius:10px;min-width:260px;display:none}
    .tabs{display:flex;border-bottom:1px solid #334155}
    .tab{flex:1;padding:8px 10px;text-align:center;cursor:pointer}
    .tab.active{background:#111827}
    .tabBody{padding:10px 12px;font:14px/1.4 system-ui,sans-serif}
    .skillbar{position:fixed;bottom:10px;left:50%;transform:translateX(-50%);display:flex;gap:8px}
    .skill{width:48px;height:48px;background:#1f2937;border:2px solid #334155;border-radius:8px;position:relative;overflow:hidden}
    .skill img{width:100%;height:100%;object-fit:cover;opacity:1}
    .skill.cd img{opacity:0.4}
    .skill .cdtimer{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;color:#fff;font-weight:bold;font-size:16px;text-shadow:0 0 4px #000}
    .pickup{position:fixed;left:50%;top:54px;transform:translateX(-50%);background:#0f172a; color:#e5e7eb; border:1px solid #334155; border-radius:10px; padding:6px 10px; font:14px/1.3 system-ui,sans-serif; display:none}
    .modal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.35)}
    .modal .card{background:#0b1220;border:1px solid #334155;color:#e5e7eb;border-radius:14px;padding:18px 20px;min-width:320px;max-width:90vw;text-align:center;box-shadow:0 10px 30px rgba(0,0,0,.5)}
    .modal .title{font:22px/1.3 system-ui,sans-serif;margin-bottom:10px}
    .modal .msg{font:14px/1.5 system-ui,sans-serif;opacity:.9;margin-bottom:16px}
    .actions{display:flex;gap:10px;justify-content:center}
    .btn{background:#1f2937;border:1px solid #334155;color:#e5e7eb;border-radius:10px;padding:8px 14px;cursor:pointer}
    .btn.primary{background:#2563eb;border-color:#1d4ed8}
    /* Multiplayer panels */
    .mpPanel{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:#0b1220;border:1px solid #334155;border-radius:12px;padding:16px 18px;color:#e5e7eb;min-width:320px;display:none}
    .mpTitle{font:18px/1.3 system-ui,sans-serif;margin-bottom:10px}
    .mpRow{margin:8px 0}
    .inp{width:100%;padding:8px 10px;border:1px solid #334155;border-radius:8px;background:#0f172a;color:#e5e7eb}
    .badge{display:inline-block;padding:4px 8px;border:1px solid #334155;border-radius:8px;background:#0f172a;margin-left:8px}
    .mpList{border:1px dashed #334155; border-radius:8px; padding:8px 10px; font:14px system-ui,sans-serif; min-height:60px}
  </style>
  <!-- PeerJS (only used on HTTPS; ignored offline) -->
  <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
</head>
<body>
  <div id="root"><canvas id="game" width="960" height="540" tabindex="0"></canvas></div>
  <div class="hint">WASD/стрелки — движение • ЛКМ — хук (через 3.5с) • M — меню • R — рестарт • Хуки видны сквозь туман • GH Pages: Multiplayer</div>
  <div id="pickup" class="pickup"></div>
  <button id="btnMenu" class="menuBtn">Главное меню</button>
  <div id="menuPanel" class="menuPanel">
    <div class="tabs">
      <div data-tab="main" class="tab active">Главная</div>
      <div data-tab="profile" class="tab">Профиль</div>
    </div>
    <div class="tabBody" id="tabMain">Добро пожаловать в Hook Arena! Нажми «Играть» (бот) или «Мультиплеер».</div>
    <div class="tabBody" id="tabProfile" style="display:none">Профиль игрока (заглушка).</div>
  </div>
  <div class="skillbar">
    <div class="skill" id="hookSkill">
      <img alt="Hook" src="data:image/svg+xml;utf8,<?xml version='1.0' encoding='UTF-8'?><svg xmlns='http://www.w3.org/2000/svg' width='48' height='48'><rect width='48' height='48' rx='8' ry='8' fill='%231f2937'/><text x='50%' y='50%' dominant-baseline='middle' text-anchor='middle' font-family='Verdana' font-size='22' fill='%23e5e7eb'>H</text></svg>"/>
      <div class="cdtimer" style="display:none"></div>
    </div>
  </div>
  <div class="hud" id="hud"></div>

  <!-- Victory/Defeat modal -->
  <div id="modal" class="modal">
    <div class="card">
      <div class="title" id="modalTitle">Победа!</div>
      <div class="msg" id="modalMsg">Противник утонул. Красиво сыграно.</div>
      <div class="actions">
        <button class="btn primary" id="btnPlayAgain">Сыграть ещё</button>
        <button class="btn" id="btnGoMain">На главную</button>
      </div>
    </div>
  </div>

  <!-- Multiplayer panels -->
  <div id="mpMenu" class="mpPanel">
    <div class="mpTitle">Мультиплеер</div>
    <div class="actions">
      <button class="btn primary" id="btnHost">Создать лобби</button>
      <button class="btn" id="btnJoin">Присоединиться</button>
      <button class="btn" id="btnCloseMp">Назад</button>
    </div>
  </div>

  <div id="mpHost" class="mpPanel">
    <div class="mpTitle">Лобби (host: <b>admin</b>) <span id="roomBadge" class="badge"></span></div>
    <div class="mpRow">Поделись кодом: <b id="roomCode">-----</b></div>
    <div class="mpRow">Игроки:</div>
    <div id="hostPlayers" class="mpList">admin (ты)</div>
    <div class="actions" style="margin-top:10px">
      <button class="btn primary" id="btnStartMp" disabled>Начать игру</button>
      <button class="btn" id="btnHostBack">Назад</button>
    </div>
    <div id="hostStatus" class="mpRow" style="opacity:.8"></div>
  </div>

  <div id="mpJoin" class="mpPanel">
    <div class="mpTitle">Присоединиться (user)</div>
    <div class="mpRow">
      <input id="joinCode" class="inp" placeholder="Код комнаты (5 цифр)" maxlength="5" />
    </div>
    <div class="actions">
      <button class="btn primary" id="btnJoinGo">Присоединиться</button>
      <button class="btn" id="btnJoinBack">Назад</button>
    </div>
    <div id="joinStatus" class="mpRow" style="opacity:.8"></div>
  </div>

  <script>
  (()=>{
    const W=960, H=540;
    const MID=W/2, RIVER_FR=0.40, RIVER_W=Math.floor(W*RIVER_FR), RIVER_HALF=Math.floor(RIVER_W/2);
    const LEFT_BANK_X=MID-RIVER_HALF, RIGHT_BANK_X=MID+RIVER_HALF;
    const PLAYER_SPEED=260, HOOK_SPEED=1100, PULL_SPEED=380, BLOCK_TIME=3500;
    const ENEMY_SIDE_LEFT = LEFT_BANK_X, ENEMY_SIDE_RIGHT = W - RIGHT_BANK_X;
    const BASE_RANGE_PLAYER = RIVER_W + ENEMY_SIDE_LEFT/3;
    const BASE_RANGE_BOT    = RIVER_W + ENEMY_SIDE_RIGHT/3;
    const FOG_ALPHA_HIDDEN=0.9, FOG_ALPHA_SEEN=0.15;
    const MP_ENABLED = (location.protocol==='https:' || location.hostname==='localhost');

    const canvas=document.getElementById('game'), ctx=canvas.getContext('2d');
    function focusCanvas(){ canvas.focus({preventScroll:true}); }
    focusCanvas();
    ['pointerdown','click','focus'].forEach(ev=>window.addEventListener(ev, focusCanvas));

    const hud=document.getElementById('hud');
    const hookSkillEl=document.getElementById('hookSkill'), hookSkillTimerEl=hookSkillEl.querySelector('.cdtimer');
    const btnMenu=document.getElementById('btnMenu'), panel=document.getElementById('menuPanel');
    const tabMain=document.getElementById('tabMain'), tabProfile=document.getElementById('tabProfile');
    const tabs=[...panel.querySelectorAll('.tab')];
    const pickupEl=document.getElementById('pickup');
    const modal=document.getElementById('modal'), modalTitle=document.getElementById('modalTitle'), modalMsg=document.getElementById('modalMsg');
    const btnPlayAgain=document.getElementById('btnPlayAgain'), btnGoMain=document.getElementById('btnGoMain');

    // Multiplayer DOM
    const mpMenu=document.getElementById('mpMenu');
    const mpHost=document.getElementById('mpHost');
    const mpJoin=document.getElementById('mpJoin');
    const btnHost=document.getElementById('btnHost');
    const btnJoin=document.getElementById('btnJoin');
    const btnCloseMp=document.getElementById('btnCloseMp');
    const btnHostBack=document.getElementById('btnHostBack');
    const btnJoinBack=document.getElementById('btnJoinBack');
    const btnJoinGo=document.getElementById('btnJoinGo');
    const joinCodeEl=document.getElementById('joinCode');
    const joinStatus=document.getElementById('joinStatus');
    const hostPlayers=document.getElementById('hostPlayers');
    const hostStatus=document.getElementById('hostStatus');
    const roomCodeEl=document.getElementById('roomCode');
    const roomBadge=document.getElementById('roomBadge');
    const btnStartMp=document.getElementById('btnStartMp');

    let screen='menu', globalLevel=1, stats={wins:0, loses:0};

    btnMenu.onclick=()=>{ panel.style.display = (panel.style.display==='block'?'none':'block') };
    tabs.forEach(t=>t.onclick=()=>{
      tabs.forEach(x=>x.classList.remove('active')); t.classList.add('active');
      const name=t.dataset.tab;
      if(name==='main'){ screen='menu'; }
      tabMain.innerHTML = `Добро пожаловать в Hook Arena! Нажми «Играть» (бот) или <b>«Мультиплеер»</b>.`;
      tabMain.appendChild(buildMainButtons());
      tabMain.style.display=(name==='main')?'block':'none';
      tabProfile.style.display=(name==='profile')?'block':'none';
      tabProfile.textContent=`Профиль: побед ${stats.wins}, поражений ${stats.loses}, глоб. сложность ${globalLevel}`;
    });

    // Add main menu buttons inside tabMain
    function buildMainButtons(){
      const wrap=document.createElement('div'); wrap.style.marginTop='10px';
      const btnPlay=document.createElement('button'); btnPlay.className='btn primary'; btnPlay.textContent='Играть (бот)';
      const btnMP=document.createElement('button'); btnMP.className='btn'; btnMP.style.marginLeft='8px'; btnMP.textContent='Мультиплеер';
      btnPlay.onclick=()=>{ startMatchSP(); };
      btnMP.onclick=()=>{
        if(!MP_ENABLED || !window.Peer){
          alert('Мультиплеер работает только на GitHub Pages (HTTPS). Сейчас доступен офлайн-режим.');
          return;
        }
        openMpMenu();
      };
      wrap.appendChild(btnPlay); wrap.appendChild(btnMP);
      return wrap;
    }

    function openMpMenu(){ mpMenu.style.display='block'; mpHost.style.display='none'; mpJoin.style.display='none'; }
    function closeMpPanels(){ mpMenu.style.display='none'; mpHost.style.display='none'; mpJoin.style.display='none'; }
    btnCloseMp.onclick=closeMpPanels;
    btnHost.onclick=()=>{ createLobby(); };
    btnJoin.onclick=()=>{ mpMenu.style.display='none'; mpJoin.style.display='block'; joinStatus.textContent=''; joinCodeEl.value=''; };
    btnHostBack.onclick=()=>{ closeMpPanels(); };
    btnJoinBack.onclick=()=>{ openMpMenu(); };

    // Modal buttons
    btnPlayAgain.onclick=()=>{ if(screen==='over'){ startMatchSP(); hideModal(); } };
    btnGoMain.onclick=()=>{ hideModal(); screen='menu'; };

    function showModal(title, msg){
      modalTitle.textContent=title; modalMsg.textContent=msg;
      modal.style.display='flex';
    }
    function hideModal(){ modal.style.display='none'; }

    // ===== Core engine (shared) =====
    const keys={};
    function onKey(e,down){
      const code=e.code;
      keys[code]=down;
      if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Space'].includes(code)) e.preventDefault();
      if(down && (code==='KeyM')){ panel.style.display=(panel.style.display==='block'?'none':'block') }
      if(down && (code==='KeyR')){ startMatchSP() }
    }
    window.addEventListener('keydown',e=>onKey(e,true), {passive:false});
    window.addEventListener('keyup',e=>onKey(e,false));
    document.addEventListener('keydown',e=>onKey(e,true), {passive:false});
    document.addEventListener('keyup',e=>onKey(e,false));

    const pointer={x:W/2,y:H/2};
    canvas.addEventListener('mousemove',e=>{ const r=canvas.getBoundingClientRect(); pointer.x=e.clientX-r.left; pointer.y=e.clientY-r.top; });

    // ===== Singleplayer (bot) from r7 =====
    // (omitted comments, same logic; returned as functions createGameSP/startMatchSP and draw routines shared)

    // We'll reuse most of the r7 engine but parameterize: mode='sp' or 'mpHost'/'mpClient'.
    // To keep this snippet concise, I include one engine with ai enabled conditional.

    function createEngine(params){
      const {mode, net} = params || {};
      const withAI = (mode==='sp');
      const isHost = (mode==='mpHost');
      const isClient = (mode==='mpClient');

      const BASE_RANGE_PLAYER = RIVER_W + ENEMY_SIDE_LEFT/3;
      const BASE_RANGE_BOT    = RIVER_W + ENEMY_SIDE_RIGHT/3;

      const player={x:RIGHT_BANK_X+100,y:H/2,vx:0,vy:0,r:12,longHookUntil:0};
      const bot   ={x:LEFT_BANK_X-100 ,y:H/2,vx:0,vy:0,r:12,longHookUntil:0};
      const hook=(owner,victim)=>({state:'idle',x:-1000,y:-1000,vx:0,vy:0,startX:0,startY:0,carry:null,owner,victim});
      const playerHook=hook(player,bot), botHook=hook(bot,player);
      const runes=[];
      let lastReveal=performance.now(), lastPower=performance.now();
      const revealDelay=4000, powerDelay=8000;
      let riverOff=0, visionUntil=0, botVisionUntil=0, startAt=performance.now(), hookCDUntil=0;
      let botCD=randInt(900,1400), botMoveTimer=0, botWaypoint=null, pickupUntil=0;

      function randInt(a,b){ return (Math.random()*(b-a)+a)|0 }
      function canThrow(){ return performance.now()-startAt>=BLOCK_TIME && performance.now()>=hookCDUntil && playerHook.state==='idle' }
      function setHookCooldown(ms){ hookCDUntil=performance.now()+ms; hookSkillEl.classList.add('cd'); hookSkillTimerEl.style.display='flex' }
      function updateCooldownUI(){ if(performance.now()<hookCDUntil){ hookSkillTimerEl.textContent=Math.max(0,Math.ceil((hookCDUntil-performance.now())/1000)); } else { hookSkillEl.classList.remove('cd'); hookSkillTimerEl.style.display='none' } }
      function throwHook(h, tx, ty){ if(h.state!=='idle') return; h.state='flying'; h.carry=null; h.x=h.owner.x; h.y=h.owner.y; h.startX=h.x; h.startY=h.y; const ang=Math.atan2(ty-h.y, tx-h.x); h.vx=Math.cos(ang)*HOOK_SPEED; h.vy=Math.sin(ang)*HOOK_SPEED; }
      function startReturn(h){ if(h.state!=='idle') h.state='returning' }
      function resetHook(h){ h.state='idle'; h.x=-1000; h.y=-1000; h.vx=h.vy=0; h.carry=null }
      const victimTouchesWater=v=> v.x>=LEFT_BANK_X && v.x<=RIGHT_BANK_X;
      function showToast(text){ pickupEl.textContent=text; pickupEl.style.display='block'; pickupUntil=performance.now()+2000 }
      function applyRune(owner, r){ if(r.type==='reveal'){ if(owner===player) visionUntil=performance.now()+3000; if(owner===bot) botVisionUntil=performance.now()+3000; } else if(r.type==='power'){ owner.longHookUntil=performance.now()+5000 } showToast(`${owner===player?'Ты':'Оппонент'} взял ${r.type==='reveal'?'жёлтую руну':'красную руну'}`) }
      function isPulled(entity){ return (playerHook.state==='pulling' && playerHook.victim===entity) || (botHook.state==='pulling' && botHook.victim===entity) }

      // Inputs
      canvas.onmousedown = ()=>{
        if(mode==='sp'){ if(canThrow()){ throwHook(playerHook, pointer.x, pointer.y); setHookCooldown(1200) } }
        if(mode==='mpHost'){ /* host is right side -> local */ if(canThrow()){ throwHook(playerHook, pointer.x, pointer.y); setHookCooldown(1200); net?.broadcast({t:'click', x:pointer.x, y:pointer.y}) } }
        if(mode==='mpClient'){ /* client is left side: send click to host */ net?.send({t:'click', x:pointer.x, y:pointer.y}); }
      };

      function aiTick(dt){
        if(!withAI) return;
        const lvl=globalLevel;
        const dodgeChance=[0,.35,.50,.65,.78,.88][lvl];
        const prediction=[0,.10,.18,.26,.34,.42][lvl];
        const jitter=[0,40,30,24,18,12][lvl];
        const cdMin=[0,900,800,700,600,520][lvl];
        const cdMax=[0,1400,1200,1100,1000,920][lvl];

        const botHasVision = performance.now() < botVisionUntil;
        const dToPlayer = Math.hypot(player.x-bot.x, player.y-bot.y);
        const needLong = (performance.now()>bot.longHookUntil) && (dToPlayer > BASE_RANGE_BOT - 5);

        const nearest = (type)=>{
          let best=null, bestD=1e9;
          for(const r of runes){ if(r.type!==type) continue; const d=Math.hypot(r.x-bot.x, r.y-bot.y); if(d<bestD){ best=r; bestD=d } }
          return {obj:best, dist:bestD};
        };
        const pow = nearest('power');
        const rev = nearest('reveal');

        let target = null;
        if(needLong && pow.obj) target=pow.obj;
        else if(!botHasVision && rev.obj) target=rev.obj;
        if(!target){
          if(!botWaypoint || botWaypoint.ttl<=0 || Math.hypot(botWaypoint.x-bot.x, botWaypoint.y-bot.y)<10){
            const x = randInt(24, LEFT_BANK_X-24);
            const y = randInt(40, H-40);
            botWaypoint = {x,y, ttl: randInt(800,1600)};
          } else {
            botWaypoint.ttl -= dt*1000;
          }
          target = botWaypoint;
        }

        const speed = 140;
        if(target){
          const ang = Math.atan2(target.y-bot.y, target.x-bot.x);
          bot.vx = Math.cos(ang)*speed;
          bot.vy = Math.sin(ang)*speed;
          if(bot.x<12 && bot.vx<0) bot.vx=0;
          if(bot.x>LEFT_BANK_X && bot.vx>0) bot.vx=0;
        }

        if(playerHook.state==='flying'){
          const toBotX=bot.x-playerHook.x, toBotY=bot.y-playerHook.y;
          const approaching=(toBotX*playerHook.vx + toBotY*playerHook.vy) > 0;
          const close=Math.hypot(toBotX,toBotY) < 360;
          if(approaching && close && Math.random()<dodgeChance){
            const len=Math.hypot(playerHook.vx,playerHook.vy)||1, px=-playerHook.vy/len, py=playerHook.vx/len;
            bot.vx=px*400; bot.vy=py*400; setTimeout(()=>{ bot.vx=0; bot.vy=0 }, 200);
          }
        }

        botCD-=dt*1000;
        if(botHook.state==='idle' && botCD<=0){
          if(needLong && pow.obj && pow.dist<=BASE_RANGE_BOT){ throwHook(botHook, pow.obj.x, pow.obj.y); botCD=randInt(cdMin, cdMax); return; }
          if(!botHasVision && rev.obj && rev.dist<=BASE_RANGE_BOT){ throwHook(botHook, rev.obj.x, rev.obj.y); botCD=randInt(cdMin, cdMax); return; }
          if(botHasVision){
            const baseRange = BASE_RANGE_BOT;
            if(dToPlayer <= baseRange || performance.now() < bot.longHookUntil){
              const tx=player.x + player.vx*prediction + (Math.random()-0.5)*2*jitter;
              const ty=player.y + player.vy*prediction + (Math.random()-0.5)*2*jitter;
              throwHook(botHook, tx, ty);
              botCD=randInt(cdMin, cdMax); return;
            }
          }
          botCD = randInt(400,900);
        }
      }

      function collectInputs(){
        return {
          keys: {
            KeyA: !!keys['KeyA'], KeyD: !!keys['KeyD'], KeyW: !!keys['KeyW'], KeyS: !!keys['KeyS'],
            ArrowLeft: !!keys['ArrowLeft'], ArrowRight: !!keys['ArrowRight'], ArrowUp: !!keys['ArrowUp'], ArrowDown: !!keys['ArrowDown']
          },
          pointer: { x: pointer.x, y: pointer.y }
        };
      }

      let lastStateSend = 0;
      function update(dt){
        const lockLeft=Math.max(0, Math.ceil((BLOCK_TIME - (performance.now()-startAt))/1000));
        hud.textContent = (mode==='sp' ? `SP •` : (isHost?`MP Host •`:`MP Client •`)) + ` Блок хука: ${lockLeft}s`;
        riverOff=(riverOff + 60*dt)%16;
        if(performance.now()>pickupUntil){ pickupEl.style.display='none'; }

        // Movement (host/SP authoritative for both players; client only sends inputs)
        if(isClient){
          // send inputs frequently
          if(net && net.conn && net.conn.open){
            net.send({t:'input', data: collectInputs()});
          }
        } else {
          // compute local inputs for "player" (right side). For host or SP.
          let vx=0,vy=0;
          const k=keys;
          if(k['KeyA']||k['ArrowLeft']) vx-=PLAYER_SPEED;
          if(k['KeyD']||k['ArrowRight']) vx+=PLAYER_SPEED;
          if(k['KeyW']||k['ArrowUp']) vy-=PLAYER_SPEED;
          if(k['KeyS']||k['ArrowDown']) vy+=PLAYER_SPEED;
          player.vx=vx; player.vy=vy;
        }

        // For MP host, apply remote user's inputs to bot-actor (left player)
        if(isHost && net && net.lastInput){
          const k=net.lastInput.keys||{};
          let vx=0,vy=0;
          if(k.KeyA||k.ArrowLeft) vx-=PLAYER_SPEED;
          if(k.KeyD||k.ArrowRight) vx+=PLAYER_SPEED;
          if(k.KeyW||k.ArrowUp) vy-=PLAYER_SPEED;
          if(k.KeyS||k.ArrowDown) vy+=PLAYER_SPEED;
          bot.vx=vx; bot.vy=vy;
        }

        // Apply movement + bounds (allow crossing while pulled)
        const beingPulledP = (playerHook.state==='pulling' && playerHook.victim===player) || (botHook.state==='pulling' && botHook.victim===player);
        const beingPulledB = (playerHook.state==='pulling' && playerHook.victim===bot) || (botHook.state==='pulling' && botHook.victim===bot);

        if(!beingPulledP){ player.x = Math.max(RIGHT_BANK_X, Math.min(W-12, player.x+player.vx*dt)); player.y = Math.max(12, Math.min(H-12, player.y+player.vy*dt)); } else { player.x+=player.vx*dt; player.y+=player.vy*dt; }
        if(!beingPulledB){ bot.x = Math.max(12, Math.min(LEFT_BANK_X, bot.x+bot.vx*dt)); bot.y = Math.max(12, Math.min(H-12, bot.y+bot.vy*dt)); } else { bot.x+=bot.vx*dt; bot.y+=bot.vy*dt; }

        const now=performance.now();
        if(now-lastReveal>revealDelay){ runes.push({x:randInt(LEFT_BANK_X+10,RIGHT_BANK_X-10), y:-10, type:'reveal', speed:PLAYER_SPEED*0.5}); lastReveal=now }
        if(now-lastPower>powerDelay){ runes.push({x:randInt(LEFT_BANK_X+10,RIGHT_BANK_X-10), y:-10, type:'power', speed:PLAYER_SPEED*0.5}); lastPower=now }

        for(let i=runes.length-1;i>=0;i--){
          const r=runes[i]; r.y+=r.speed*dt;
          if(r.y>H+20){ runes.splice(i,1); continue }
          if(Math.hypot(player.x-r.x, player.y-r.y) < 20){ applyRune(player,r); runes.splice(i,1); continue }
          if(Math.hypot(bot.x-r.x, bot.y-r.y) < 20){ applyRune(bot,r); runes.splice(i,1); continue }
        }

        // Hooks
        [playerHook, botHook].forEach(h=>{
          if(h.state==='flying'){
            h.x+=h.vx*dt; h.y+=h.vy*dt;
            const baseRange = (h.owner===player) ? BASE_RANGE_PLAYER : BASE_RANGE_BOT;
            const maxR = ((h.owner.longHookUntil||0) > now) ? W : baseRange;
            const traveled = Math.hypot(h.x-h.startX, h.y-h.startY);
            if(traveled>maxR) startReturn(h);
            if(Math.hypot(h.x-h.victim.x, h.y-h.victim.y) < 14){ h.state='pulling'; h.vx=h.vy=0; h.x=h.victim.x; h.y=h.victim.y }
            for(let i=0;i<runes.length;i++){ const r=runes[i]; if(Math.hypot(h.x-r.x, h.y-r.y) < 12){ h.state='returning'; h.carry=r; runes.splice(i,1); break } }
          } else if(h.state==='returning'){
            const ang=Math.atan2(h.owner.y-h.y, h.owner.x-h.x);
            h.vx=Math.cos(ang)*HOOK_SPEED; h.vy=Math.sin(ang)*HOOK_SPEED;
            h.x+=h.vx*dt; h.y+=h.vy*dt;
            if(h.carry){ h.carry.x=h.x; h.carry.y=h.y }
            if(Math.hypot(h.owner.x-h.x, h.owner.y-h.y) < 16){
              if(h.carry){ applyRune(h.owner,h.carry); h.carry=null; }
              resetHook(h);
            }
          } else if(h.state==='pulling'){
            const ang=Math.atan2(h.owner.y-h.victim.y, h.owner.x-h.victim.x);
            h.victim.vx=Math.cos(ang)*PULL_SPEED; h.victim.vy=Math.sin(ang)*PULL_SPEED;
            if(victimTouchesWater(h.victim)){
              resetHook(h);
              // Game end
              if(mode==='sp'){ endMatch(true); }
              if(mode==='mpHost'){ net.broadcast({t:'end', winner: (h.owner===player?'admin':'user')}); endMatch(h.owner===player); }
            }
          }
        });

        if(withAI) aiTick(dt);
        updateCooldownUI();

        // MP host: send state snapshots ~20Hz
        if(isHost && net && net.conn && net.conn.open){
          const nowms = performance.now();
          if(nowms - lastStateSend > 50){
            lastStateSend = nowms;
            const state = {
              t: 'state',
              s: {
                player, bot,
                playerHook, botHook,
                runes, visionUntil, botVisionUntil, startAt, hookCDUntil
              }
            };
            net.broadcast(state);
          }
        }
      }

      function render(){
        ctx.clearRect(0,0,W,H);
        // Background & river
        ctx.fillStyle='#0f172a'; ctx.fillRect(0,0,W,H);
        for(let x=LEFT_BANK_X; x<RIGHT_BANK_X; x+=16){
          for(let y=((riverOff|0)%16)-16; y<H; y+=16){
            ctx.fillStyle='#2563eb'; ctx.fillRect(x,y,16,16);
            ctx.strokeStyle='rgba(96,165,250,0.7)';
            ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x+16,y+16);
            ctx.moveTo(x+16,y); ctx.lineTo(x,y+16); ctx.stroke();
          }
        }
        // Runes
        for(const r of runes){
          ctx.fillStyle = (r.type==='power') ? '#ff4444' : '#ffff66';
          ctx.beginPath(); ctx.arc(r.x,r.y,8,0,Math.PI*2); ctx.fill();
          if(r.type==='power'){ ctx.strokeStyle='white'; ctx.lineWidth=2; ctx.stroke() }
        }
        // Player on right
        drawRect(player.x-12, player.y-12, 24, 24, 5, '#38bdf8');
        // Enemy (left) visible only on reveal
        const enemyVisible = performance.now() < visionUntil;
        if(enemyVisible){ drawRect(bot.x-12, bot.y-12, 24, 24, 5, '#f59e0b'); }
        // Fog left side
        ctx.fillStyle = `rgba(0,0,0,${enemyVisible?FOG_ALPHA_SEEN:FOG_ALPHA_HIDDEN})`; ctx.fillRect(0,0,LEFT_BANK_X,H);
        // Hooks always visible
        [playerHook, botHook].forEach(h=>{
          if(h.state==='idle') return;
          ctx.strokeStyle='#94a3b8'; ctx.lineWidth=3;
          ctx.beginPath(); ctx.moveTo(h.owner.x,h.owner.y); ctx.lineTo(h.x,h.y); ctx.stroke();
          ctx.fillStyle='#f97316'; ctx.beginPath(); ctx.arc(h.x,h.y,6,0,Math.PI*2); ctx.fill();
          ctx.strokeStyle='white'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(h.x,h.y,6,0,Math.PI*2); ctx.stroke();
          if(h.carry){ ctx.fillStyle=(h.carry.type==='power')?'#ff4444':'#ffff66'; ctx.beginPath(); ctx.arc(h.carry.x,h.carry.y,8,0,Math.PI*2); ctx.fill(); if(h.carry.type==='power'){ ctx.strokeStyle='white'; ctx.lineWidth=2; ctx.stroke() } }
        });
      }

      function drawRect(x,y,w,h,r,fill){ ctx.fillStyle=fill; roundRect(ctx,x,y,w,h,r,true,false); }
      function roundRect(ctx, x, y, w, h, r, fill, stroke){
        if(typeof r === 'number'){ r={tl:r,tr:r,br:r,bl:r} }
        ctx.beginPath();
        ctx.moveTo(x+r.tl,y); ctx.lineTo(x+w-r.tr,y); ctx.quadraticCurveTo(x+w,y,x+w,y+r.tr);
        ctx.lineTo(x+w,y+h-r.br); ctx.quadraticCurveTo(x+w,y+h,x+w-r.br,y+h);
        ctx.lineTo(x+r.bl,y+h); ctx.quadraticCurveTo(x,y+h,x,y+h-r.bl);
        ctx.lineTo(x,y+r.tl); ctx.quadraticCurveTo(x,y,x+r.tl,y); ctx.closePath();
        if(fill) ctx.fill(); if(stroke) ctx.stroke();
      }

      function endMatch(playerWon){
        screen='over';
        if(mode==='sp'){
          if(playerWon){ stats.wins++; globalLevel=Math.min(5,globalLevel+1); showModal('Победа!', 'Бот утонул. Красиво сыграно.'); }
          else{ stats.loses++; globalLevel=Math.max(1,globalLevel-1); showModal('Поражение', 'Ты утонул. Попробуешь ещё раз?'); }
        } else {
          if(isHost){
            showModal(playerWon?'Победа!':'Поражение', playerWon?'Противник утонул.':'Ты утонул.');
          } else if(isClient){
            // Client relies on host to send 'end' and will show accordingly in net handler
          }
        }
      }

      return {
        update, render,
        canThrow(){ return canThrow() },
        throwPlayerHook(x,y){ if(canThrow()){ throwHook(playerHook,x,y); setHookCooldown(1200) } },
        // MP networking helpers
        applyRemoteState(s){
          // Deep copy primitives (avoid ref sharing)
          ['x','y','vx','vy','r','longHookUntil'].forEach(k=>{ player[k]=s.player[k]; bot[k]=s.bot[k]; });
          Object.assign(playerHook, s.playerHook); playerHook.owner=player; playerHook.victim=bot;
          Object.assign(botHook, s.botHook); botHook.owner=bot; botHook.victim=player;
          runes.length=0; for(const r of s.runes){ runes.push({...r}); }
          visionUntil=s.visionUntil; botVisionUntil=s.botVisionUntil; hookCDUntil=s.hookCDUntil; // startAt can be ignored
        }
      };
    }

    let engine=null, prev=performance.now();
    function loop(now){
      const dt=Math.min(0.033,(now-prev)/1000); prev=now;
      if(screen==='game' && engine){ engine.update(dt); engine.render(); }
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    function startMatchSP(){ closeMpPanels(); engine=createEngine({mode:'sp'}); screen='game'; }

    // ===== Multiplayer via PeerJS =====
    let peer=null, conn=null, roomCode=null;

    function makeRoomCode(){ return String(Math.floor(10000+Math.random()*90000)) }
    function roomIdFromCode(code){ return 'hookarena-'+code }

    function createLobby(){
      openMpMenu(); mpMenu.style.display='none'; mpHost.style.display='block'; hostPlayers.textContent='admin (ты)'; hostStatus.textContent='';
      roomCode = makeRoomCode();
      roomCodeEl.textContent = roomCode;
      roomBadge.textContent = 'код действует пока ты в лобби';
      const peerId = roomIdFromCode(roomCode);
      try{
        peer = new Peer(peerId, { debug: 1 });
        peer.on('open', id => { hostStatus.textContent='Ожидание подключения...'; });
        peer.on('connection', c => {
          conn = c; hostStatus.textContent='Игрок подключился (user)'; hostPlayers.textContent='admin (ты)\nuser';
          conn.on('data', onClientMsg);
          conn.on('close', ()=>{ hostStatus.textContent='Игрок отключился'; btnStartMp.disabled=true; hostPlayers.textContent='admin (ты)'; });
          btnStartMp.disabled=false;
        });
        peer.on('error', err => { hostStatus.textContent='Ошибка: '+err; });
      }catch(e){ hostStatus.textContent='PeerJS не доступен (нужен HTTPS).'; }
    }

    btnStartMp.onclick=()=>{
      if(conn && conn.open){
        conn.send({t:'start'});
        startMatchMPHost();
      }
    };

    function startMatchMPHost(){
      closeMpPanels(); engine=createEngine({mode:'mpHost', net:{
        conn,
        broadcast(msg){ if(conn && conn.open) conn.send(msg) },
        lastInput:null,
        send(){}
      }}); screen='game';
    }

    function onClientMsg(msg){
      if(!msg||!engine) return;
      if(msg.t==='input'){ if(engine && engine.update){ /* host stores last input */ engine.__net = engine.__net||{}; } if(engine && engine.update){ /* stash */ } if(currentNet) currentNet.lastInput = msg.data; }
      if(msg.t==='click'){ if(engine && engine.throwPlayerHook){ /* left player click handled by engine via host mapping in update loop */ /* we can't directly call throw; engine checks mode */ } }
    }

    // because closure, store reference to current net object
    let currentNet=null;
    function startMatchMPClient(){
      closeMpPanels(); engine=createEngine({mode:'mpClient', net:{
        conn,
        send(msg){ if(conn && conn.open) conn.send(msg) }
      }}); screen='game';
    }

    // Hook PeerJS join
    btnJoinGo.onclick=()=>{
      const code = (joinCodeEl.value||'').trim();
      if(!/^\d{5}$/.test(code)){ joinStatus.textContent='Введите 5 цифр.'; return; }
      joinStatus.textContent='Подключение...';
      try{
        peer = new Peer(undefined, { debug: 1 });
        peer.on('open', id => {
          const idHost = roomIdFromCode(code);
          conn = peer.connect(idHost);
          conn.on('open', ()=>{ joinStatus.textContent='Подключено! Ожидаем старт.'; startMatchMPClient(); conn.on('data', onHostMsg); });
          conn.on('error', err=>{ joinStatus.textContent='Ошибка соединения: '+err });
          conn.on('close', ()=>{ joinStatus.textContent='Соединение закрыто'; });
        });
        peer.on('error', err => { joinStatus.textContent='Ошибка Peer: '+err });
      }catch(e){ joinStatus.textContent='PeerJS не доступен (нужен HTTPS).'; }
    };

    function onHostMsg(msg){
      if(!msg) return;
      if(msg.t==='state' && engine && engine.applyRemoteState){ engine.applyRemoteState(msg.s) }
      if(msg.t==='end'){ showModal(msg.winner==='admin' ? 'Поражение' : 'Победа!', msg.winner==='admin' ? 'Хост утопил тебя.' : 'Ты утопил хоста.'); screen='over'; }
      if(msg.t==='start'){ /* already in game; nothing extra to do */ }
    }

    // helper to attach net object reference from engine creation
    const origCreateEngine = createEngine;
    function createEngineWrapper(params){ const eng = origCreateEngine(params); currentNet = params?.net || null; return eng }
    createEngine = createEngineWrapper;

    // ===== Rendering helpers for menu tab content on load
    // Trigger initial tab setup
    tabs[0].click();

    // Utilities for drawing rounded rects in the outer scope
    function roundRect(ctx, x, y, w, h, r, fill, stroke){
      if(typeof r === 'number'){ r={tl:r,tr:r,br:r,bl:r} }
      ctx.beginPath();
      ctx.moveTo(x+r.tl,y); ctx.lineTo(x+w-r.tr,y); ctx.quadraticCurveTo(x+w,y,x+w,y+r.tr);
      ctx.lineTo(x+w,y+h-r.br); ctx.quadraticCurveTo(x+w,y+h,x+w-r.br,y+h);
      ctx.lineTo(x+r.bl,y+h); ctx.quadraticCurveTo(x,y+h,x,y+h-r.bl);
      ctx.lineTo(x,y+r.tl); ctx.quadraticCurveTo(x,y,x+r.tl,y); ctx.closePath();
      if(fill) ctx.fill(); if(stroke) ctx.stroke();
    }
  })();
  </script>
</body>
</html>
